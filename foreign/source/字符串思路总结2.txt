1.多个串的最长公共子串
(i)sa:二分答案分组。
(ii)sam:对第一个串建立sam，其他匹配，对每个节点维护到达该节点所能匹配上的最大长度，按照拓扑倒序用每个节点去更新parent节点。
2.重复次数最多的连续重复子串:
枚举长度L，求长度为L的子串最多的连续次数。枚举位置0,L,2L,3L……s[L*i]和s[L*(i+1)]往前和往后能匹配的总长度为k，那么这里连续出现了k/L+1次。
3.统计子串数目问题
(1)本质不同的子串个数：
(i)n-sa[i]-height[i](0-base)
(ii)T[x].len-T[T[x].root].len。
(iii)siz[x]=∑siz[T[x].nx[i]]+1。
(2)长度不小于k的公共子串(S和T)的个数(位置不同算多次)
(i)sa:后缀分组，用单调栈维护T后缀和前面所有S后缀的lcp之和，S后缀和前面的所有T后缀类似。
(ii)sam:构建S的sam，T匹配。
f[x] += (T[x].len - max(T[T[x].root].len + 1, k) + 1) * siz[x];
ans += f[T[p].root] + (len - max(T[T[p].root].len + 1, k) + 1) * siz[p];
4.出现问题
(1)多次出现算多次:
多次询问串a在串b中出现了多少次。
考虑单次询问,将串b的每个前缀在fail树中对应的节点到根的路径+1,求串a在fail树中对应的节点被标记了多少次。
对于多次询问,只需要将询问按照b在打字机串中出现的顺序排序更新即可。
(2)多次出现算一次:
有两个字符串集合A,B，询问A中的每个串a被B中的多少个串b包含，询问B中的每个串b包含A中的多少个串a。 
对集合A中的串建立自动机： 
每个a的答案是该串对应的节点的子树中出现了多少个b串的前缀(只需要在危险节点处标记),数颜色问题。 
每个b的答案是该串的所有前缀对应的节点到根节点的路径上出现了多少个不同的串a,树链的并。 
求出siz[x]表示节点x以及它的所有后缀中有多少个串a,将b所有前缀对应的节点按照dfs序统计即可。 
5.找第K小的子串siz[x]=∑siz[T[x].nx[i]]+1/siz[x]=∑siz[T[x].nx[i]]+right集合的大小。