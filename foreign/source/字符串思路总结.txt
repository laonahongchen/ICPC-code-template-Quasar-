1.公共子串问题
(1)两个串的最长公共子串
(i)sa做法:排名相邻但不在同一个串中的两个后缀的height的最大值。
(ii)sam做法:对第一个串建立sam,另一个串匹配,能匹配到的最大长度就是答案。
(2)多个串的最长公共子串
(i)sa做法:二分答案后分组，判断组内的后缀是否覆盖了所有串。 
(ii)sam做法:对第一个串建立sam，其他串进行匹配，对每个节点维护到达该节点所能匹配上的最大长度，按照拓扑序倒序用每个节点去更新他的parent节点。
2.重复子串问题
(1)可重叠最长重复子串：给定一个字符串，求最长重复子串，这两个子串可以重叠。
只需求height数组的最大值。
(2)不可重叠最长重复子串：给定一个字符串，求最长重复子串，这两个子串不能重叠。
二分答案，判断是否存在两个长度为k的子串相同且不重叠。利用height把后缀分成若干组，两个后缀一定在同一组，只需判断每组中sa的最大值和最小值之差是否不小于k。
(3)重复次数最多的连续重复子串:
枚举长度L，求长度为L的子串最多的连续次数。枚举位置0,L,2L,3L……看s[L*i]和s[L*(i+1)]往前和往后各能匹配到多远，总长度为k，那么这里连续出现了k/L+1次。
O(n/1+n/2+n/3+……+n/n)=O(nlnn)。
3.统计子串数目问题
(1)本质不同的子串个数：
(i)sa做法:n-sa[i]-height[i]之和(0-base)。
(ii)sam做法:所有节点表示的字符串区间长度之和，即T[x].len-T[T[x].root].len之和。
(iii)sam做法:统计从x出发的路径条数(包含只有一个点的路径)siz[x]=∑siz[T[x].nx[i]]+1。
(2)任意两个后缀的LCP之和：
(i)sa做法:将后缀排序，对于每个后缀统计它和前面的串的LCP之和，用单调栈维护从后向前递减的height。
(ii)sam做法:对反串建立sam，构建出后缀树，统计每个节点作为lcp的后缀的对数，dp出每个节点的子树中有多少个后缀对应的节点。
(3)长度不小于k的公共子串(S和T)的个数(位置不同算多次)
(i)sa做法:将后缀排序，按照height>=k分组，两个后缀的贡献是lcp-k+1，用单调栈维护T后缀和前面所有S后缀的lcp之和，S后缀和前面的所有T后缀类似。
(ii)sam做法:构建S的sam，T匹配。
f[x] += (T[x].len - max(T[T[x].root].len + 1, k) + 1) * siz[x];
ans += f[T[p].root] + (len - max(T[T[p].root].len + 1, k) + 1) * siz[p];
(4)N个字符串，求每个字符串有多少个子串是这N个串中至少K个串中的子串。
构建广义后缀自动机，问题转化成fail树中每个节点的子树中有多少种不同的颜色，用树状数组维护。
4.出现问题
(1)多次出现算多次:
多次询问串a在串b中出现了多少次。
考虑单次询问,将串b的每个前缀在fail树中对应的节点到根的路径+1,那么只需要求出串a在fail树中对应的节点被标记了多少次。
对于多次询问,只需要将询问按照b在打字机串中出现的顺序排序更新即可。
(2)多次出现算一次:
有两个字符串集合A,B，询问A中的每个串a被B中的多少个串b包含，询问B中的每个串b包含A中的多少个串a。 
对集合A中的串建立自动机： 
每个串a的答案就是该串在fail树中对应的节点的子树中出现了多少个b串的前缀(只需要在危险节点处标记),问题转化成经典的数颜色问题。 
每个串b的答案就是该串的所有前缀在fail树中对应的节点到根节点的路径上出现了多少个不同的串a,问题转化成树链的并。 
求出siz[x]表示节点x以及它的所有后缀中有多少个串a,将b所有前缀对应的节点按照dfs序统计即可。 
5.其他
(1)最小循环表示
将原串S倍增，建立sam，每次当前连出走字典序最小的点，一直走到长度为|S|为止。
(2)找第K小的子串
(i)位置不同算一次:统计路径条数siz[x]=∑siz[T[x].nx[i]]+1,找字典序第小的路径。
(ii)位置不同算多次:同上，siz[x]=∑siz[T[x].nx[i]]+right集合的大小。
(3)最长回文子串
枚举以每个字符为中心的最长回文子串(奇数和偶数)。将整个字符串反过来写在原字符串后面，中间用一个特殊的字符隔开，构建后缀数组查询。